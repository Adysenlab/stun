'use strict';

// This file contains definition of StunMessage classes.

const crypto = require('crypto');
const {
  createEncodeStream,
  encode,
  decode,
  encodingLength,
  types: { array },
} = require('binary-data');
const { crc32 } = require('crc');
const constants = require('lib/constants');
const { StunMessagePacket, StunAttributePacket } = require('lib/protocol');
const attributes = require('lib/attributes');

const {
  attributeType,
  kStunFingerprintXorValue,
  kStunFingerprintLength,
  kStunMessageIntegrityLength,
  kStunTransactionIdLength,
  kStunMessageIntegritySize,
  kStunLegacyTransactionIdLength,
} = constants;

const EMPTY_TRANSACTION_ID = Buffer.alloc(kStunTransactionIdLength, 0);

const EMPTY_BUFFER = Buffer.alloc(0);
const EMPTY_MESSAGE_INTEGRITY = Buffer.alloc(kStunMessageIntegritySize, 0);

const toUInt32 = x => x >>> 0; // eslint-disable-line no-bitwise

const kMessageType = Symbol('kMessageType');
const kTransactionId = Symbol('kTransctionId');
const kCookie = Symbol('kCookie');
const kAttributes = Symbol('kAttributes');

/**
 * This class implements a STUN message.
 */
class StunMessage {
  /**
   * @class StunMessage
   */
  constructor() {
    this[kMessageType] = 0;
    this[kTransactionId] = EMPTY_TRANSACTION_ID;
    this[kAttributes] = [];
    this[kCookie] = constants.kStunMagicCookie;
  }

  /**
   * Get the type of the message.
   * @returns {number}
   */
  get type() {
    return this[kMessageType];
  }

  /**
   * Get transaction id field.
   * @returns {Buffer}
   */
  get transactionId() {
    return this[kTransactionId];
  }

  /**
   * Get the number of an attributes in current message.
   * @returns {number} The number of an attributes in current message.
   */
  get count() {
    return this[kAttributes].length;
  }

  /**
   * Set message type.
   * @param {number} type - A message type, see constants.
   */
  setType(type) {
    this[kMessageType] = Number(type);
  }

  /**
   * Set `transaction` field for cuurent message.
   * @param {Buffer} transactionId The value of `transaction` field.
   * @returns {boolean} Was the operation successful or not.
   */
  setTransactionID(transactionId) {
    if (!isValidTransactionId(transactionId)) {
      return false;
    }

    this[kTransactionId] = transactionId;
    return true;
  }

  /**
   * Create an instance of StunMessage from Buffer.
   * @param {Buffer} message Encoded to the buffer stun message.
   * @returns {StunMessage} StunMessage instance.
   */
  static from(message) {
    const packet = decode(message, StunMessagePacket);

    const stunMsg = new StunMessage();

    stunMsg.setType(packet.header.type);
    stunMsg.setTransactionID(packet.header.transaction);
    stunMsg[kCookie] = packet.header.cookie;

    stunMsg[kAttributes] = packet.attributes.map(attrPacket =>
      attributes.parse(attrPacket, stunMsg)
    );

    return stunMsg;
  }

  /**
   * Returns true if the message confirms to RFC3489 rather than RFC5389.
   * @returns {boolean} The result of an operation.
   */
  isLegacy() {
    return this[kCookie] !== constants.kStunMagicCookie;
  }

  /**
   * Add an attribute for stun message.
   * @param {number} type Attribute type.
   * @param {*} args Values of an attribute.
   * @returns {StunAttribute} Created attribute.
   */
  addAttribute(type, ...args) {
    const attr = attributes.create(type, ...args);

    attr.setOwner(this);
    this[kAttributes].push(attr);

    return attr;
  }

  /**
   * Return a STUN attribute by it type or undefined.
   * @param {number} type - Attribute type.
   * @returns {StunAttribute|undefined} Instance of StunAttribute or undefined attribute doesn't exist.
   */
  getAttribute(type) {
    return this[kAttributes].find(attr => attr.type === type);
  }

  /**
   * Remove attribute from current message.
   * @param {number} type - Attribute type.
   * @returns {boolean} The result of an operation.
   */
  removeAttribute(type) {
    const index = this[kAttributes].findIndex(attr => attr.type === type);

    if (index === -1) {
      return false;
    }

    switch (index) {
      case 0:
        this[kAttributes].shift();
        break;
      case this[kAttributes].length - 1:
        this[kAttributes].pop();
        break;
      default:
        this[kAttributes].splice(index, 1);
        break;
    }

    return true;
  }

  /**
   * Adds a MESSAGE-INTEGRITY attribute that is valid for the current message.
   * @param {string} key Secret hmac key.
   * @returns {boolean} The result of an operation.
   */
  addMessageIntegrity(key) {
    if (!key) {
      return false;
    }

    const attrIntegrity = this.addAttribute(
      attributeType.MESSAGE_INTEGRITY,
      EMPTY_MESSAGE_INTEGRITY
    );
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const hmac = crypto.createHmac('sha1', key);
    hmac.update(msg.slice(0, -kStunMessageIntegrityLength));

    return attrIntegrity.setValue(hmac.digest());
  }

  /**
   * Adds a FINGERPRINT attribute that is valid for the current message.
   *
   * @returns {boolean} The result of an operation.
   */
  addFingerprint() {
    const attrFingerprint = this.addAttribute(attributeType.FINGERPRINT, 0);
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const crc32buf = msg.slice(0, -kStunFingerprintLength);
    return attrFingerprint.setValue(
      toUInt32(crc32(crc32buf) ^ kStunFingerprintXorValue) // eslint-disable-line no-bitwise
    );
  }

  /**
   * Convert current message to the Buffer.
   *
   * @private
   * @param {Object} encodeStream Output stream from binary-data.
   * @returns {boolean} The result of an operation.
   */
  write(encodeStream) {
    const attrs = this[kAttributes].map(attr => ({
      type: attr.type,
      value: attr.toBuffer(),
    }));

    const packet = {
      header: {
        type: this.type,
        length: encodingLength(attrs, array(StunAttributePacket, attrs.length)),
        cookie: this[kCookie],
        transaction: this.transactionId,
      },
      attributes: attrs,
    };

    encode(packet, encodeStream, StunMessagePacket);
    return true;
  }

  /**
   * Convert current message to the Buffer.
   * @returns {Buffer} Encoded stun message.
   */
  toBuffer() {
    const encodeStream = createEncodeStream();

    if (this.write(encodeStream)) {
      return encodeStream.slice();
    }

    return EMPTY_BUFFER;
  }
}

/**
 * Iterator over attributes.
 */
StunMessage.prototype[Symbol.iterator] = function* iterator() {
  for (const attribute of this[kAttributes]) {
    yield attribute;
  }
};

/**
 * Check if tranasction id is valid.
 * @param {Buffer} transactionId - `transction` field from a stun message.
 * @returns {boolean} The result of an operation.
 */
function isValidTransactionId(transactionId) {
  return (
    Buffer.isBuffer(transactionId) &&
    (transactionId.length === kStunTransactionIdLength ||
      transactionId.length === kStunLegacyTransactionIdLength)
  );
}

module.exports = StunMessage;
