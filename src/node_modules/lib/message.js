'use strict';

// This file contains definition of StunMessage classes.

const crypto = require('crypto');
const {
  createEncodeStream,
  encode,
  decode,
  encodingLength,
  types: { array },
} = require('binary-data');
const { crc32 } = require('crc');
const constants = require('lib/constants');
const { StunMessagePacket, StunAttributePacket } = require('lib/protocol');
const StunAddressAttribute = require('attributes/stun-address-attribute');
const StunXorAddressAttribute = require('attributes/stun-xor-address-attribute');
const StunUInt32Attribute = require('attributes/stun-uint32-attribute');
const StunByteStringAttribute = require('attributes/stun-bytestring-attribute');
const StunErrorCodeAttribute = require('attributes/stun-error-code-attribute');
const StunUInt16ListAttribute = require('attributes/stun-uint16list-attribute');
const StunUnknownAttribute = require('attributes/stun-unknown-attribute');
const StunUInt16Attribute = require('attributes/stun-uint16-attribute');

const {
  attributeType,
  attributeValueType,
  kStunFingerprintXorValue,
  kStunFingerprintLength,
  kStunMessageIntegrityLength,
  kStunTransactionIdLength,
  kStunMessageIntegritySize,
  kStunLegacyTransactionIdLength,
} = constants;

const EMPTY_TRANSACTION_ID = Buffer.alloc(kStunTransactionIdLength, 0);

const EMPTY_BUFFER = Buffer.alloc(0);
const EMPTY_MESSAGE_INTEGRITY = Buffer.alloc(kStunMessageIntegritySize, 0);

const toUInt32 = x => x >>> 0; // eslint-disable-line no-bitwise

const kMessageType = Symbol('kMessageType');
const kTransactionId = Symbol('kTransctionId');
const kCookie = Symbol('kCookie');
const kAttributes = Symbol('kAttributes');

/**
 * This class implements a STUN message.
 */
class StunMessage {
  /**
   * @class StunMessage
   */
  constructor() {
    this[kMessageType] = 0;
    this[kTransactionId] = EMPTY_TRANSACTION_ID;
    this[kAttributes] = [];
    this[kCookie] = constants.kStunMagicCookie;
  }

  /**
   * Get the type of the message.
   * @returns {number}
   */
  get type() {
    return this[kMessageType];
  }

  /**
   * Get transaction id field.
   * @returns {Buffer}
   */
  get transactionId() {
    return this[kTransactionId];
  }

  /**
   * Get the number of an attributes in current message.
   * @returns {number} The number of an attributes in current message.
   */
  get count() {
    return this[kAttributes].length;
  }

  /**
   * Set message type.
   * @param {number} type - A message type, see constants.
   */
  setType(type) {
    this[kMessageType] = Number(type);
  }

  /**
   * Set `transaction` field for cuurent message.
   * @param {Buffer} transactionId The value of `transaction` field.
   * @returns {boolean} Was the operation successful or not.
   */
  setTransactionID(transactionId) {
    if (!isValidTransactionId(transactionId)) {
      return false;
    }

    this[kTransactionId] = transactionId;
    return true;
  }

  /**
   * Create an instance of StunMessage from Buffer.
   * @param {Buffer} message Encoded to the buffer stun message.
   * @returns {StunMessage} StunMessage instance.
   */
  static from(message) {
    const packet = decode(message, StunMessagePacket);

    const stunMsg = new StunMessage();

    stunMsg.setType(packet.header.type);
    stunMsg.setTransactionID(packet.header.transaction);

    this[kCookie] = packet.header.cookie;

    stunMsg[kAttributes] = packet.attributes.map(attrPacket =>
      parseAttribute(attrPacket, stunMsg)
    );

    return stunMsg;
  }

  /**
   * Returns true if the message confirms to RFC3489 rather than RFC5389.
   * @returns {boolean} The result of an operation.
   */
  isLegacy() {
    return this[kCookie] !== constants.kStunMagicCookie;
  }

  /**
   * Add an attribute for stun message.
   * @param {number} type Attribute type.
   * @param {*} args Values of an attribute.
   * @returns {StunAttribute} Created attribute.
   */
  addAttribute(type, ...args) {
    const attr = createAttribute(type, ...args);

    attr.setOwner(this);
    this[kAttributes].push(attr);

    return attr;
  }

  /**
   * Return a STUN attribute by it type or undefined.
   * @param {number} type - Attribute type.
   * @returns {StunAttribute|undefined} Instance of StunAttribute or undefined attribute doesn't exist.
   */
  getAttribute(type) {
    return this[kAttributes].find(attr => attr.type === type);
  }

  /**
   * Remove attribute from current message.
   * @param {number} type - Attribute type.
   * @returns {boolean} The result of an operation.
   */
  removeAttribute(type) {
    const index = this[kAttributes].findIndex(attr => attr.type === type);

    if (index === -1) {
      return false;
    }

    switch (index) {
      case 0:
        this[kAttributes].shift();
        break;
      case this[kAttributes].length - 1:
        this[kAttributes].pop();
        break;
      default:
        this[kAttributes].splice(index, 1);
        break;
    }

    return true;
  }

  /**
   * Adds a MESSAGE-INTEGRITY attribute that is valid for the current message.
   * @param {string} key Secret hmac key.
   * @returns {boolean} The result of an operation.
   */
  addMessageIntegrity(key) {
    if (!key) {
      return false;
    }

    const attrIntegrity = this.addAttribute(
      attributeType.MESSAGE_INTEGRITY,
      EMPTY_MESSAGE_INTEGRITY
    );
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const hmac = crypto.createHmac('sha1', key);
    hmac.update(msg.slice(0, -kStunMessageIntegrityLength));

    return attrIntegrity.setValue(hmac.digest());
  }

  /**
   * Adds a FINGERPRINT attribute that is valid for the current message.
   *
   * @returns {boolean} The result of an operation.
   */
  addFingerprint() {
    const attrFingerprint = this.addAttribute(attributeType.FINGERPRINT, 0);
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const crc32buf = msg.slice(0, -kStunFingerprintLength);
    return attrFingerprint.setValue(
      toUInt32(crc32(crc32buf) ^ kStunFingerprintXorValue) // eslint-disable-line no-bitwise
    );
  }

  /**
   * Convert current message to the Buffer.
   *
   * @private
   * @param {Object} encodeStream Output stream from binary-data.
   * @returns {boolean} The result of an operation.
   */
  write(encodeStream) {
    const attributes = this[kAttributes].map(attr => ({
      type: attr.type,
      value: attr.toBuffer(),
    }));

    const packet = {
      header: {
        type: this.type,
        length: encodingLength(
          attributes,
          array(StunAttributePacket, attributes.length)
        ),
        cookie: this[kCookie],
        transaction: this.transactionId,
      },
      attributes,
    };

    encode(packet, encodeStream, StunMessagePacket);
    return true;
  }

  /**
   * Convert current message to the Buffer.
   * @returns {Buffer} Encoded stun message.
   */
  toBuffer() {
    const encodeStream = createEncodeStream();

    if (this.write(encodeStream)) {
      return encodeStream.slice();
    }

    return EMPTY_BUFFER;
  }
}

/**
 * Iterator over attributes.
 */
StunMessage.prototype[Symbol.iterator] = function* iterator() {
  for (const attribute of this[kAttributes]) {
    yield attribute;
  }
};

/**
 * @param {number} attrType Attribute type.
 * @returns {number} Type of an attribute's value.
 * @private
 */
function getAttributeValueType(attrType) {
  switch (attrType) {
    case attributeType.MAPPED_ADDRESS:
    case attributeType.ALTERNATE_SERVER:
    case attributeType.RESPONSE_ORIGIN:
    case attributeType.OTHER_ADDRESS:
      return attributeValueType.ADDRESS;

    case attributeType.XOR_MAPPED_ADDRESS:
    case attributeType.XOR_PEER_ADDRESS:
    case attributeType.XOR_RELAYED_ADDRESS:
      return attributeValueType.XOR_ADDRESS;

    case attributeType.USERNAME:
    case attributeType.MESSAGE_INTEGRITY:
    case attributeType.REALM:
    case attributeType.NONCE:
    case attributeType.SOFTWARE:
    case attributeType.ORIGIN:
    case attributeType.DATA:
    case attributeType.EVEN_PORT:
    case attributeType.RESERVATION_TOKEN:
    case attributeType.DONT_FRAGMENT:
    case attributeType.PADDING:
      return attributeValueType.BYTE_STRING;

    case attributeType.ERROR_CODE:
      return attributeValueType.ERROR_CODE;

    case attributeType.UNKNOWN_ATTRIBUTES:
      return attributeValueType.UINT16_LIST;

    case attributeType.FINGERPRINT:
    case attributeType.RETRANSMIT_COUNT:
    case attributeType.PRIORITY:
    case attributeType.NETWORK_INFO:
    case attributeType.NOMINATION:
    case attributeType.CHANNEL_NUMBER:
    case attributeType.LIFETIME:
    case attributeType.REQUESTED_TRANSPORT:
    case attributeType.CHANGE_REQUEST:
      return attributeValueType.UINT32;

    case attributeType.USE_CANDIDATE:
    case attributeType.ICE_CONTROLLED:
    case attributeType.ICE_CONTROLLING:
      return attributeValueType.BYTE_STRING;

    case attributeType.RESPONSE_PORT:
      return attributeValueType.UINT16;

    default:
      return attributeValueType.UNKNOWN;
  }
}

/**
 * Create attribute.
 * @param {number} type Attribute type.
 * @param  {...any} args Values.
 * @returns {StunAttribute}
 */
function createAttribute(type, ...args) {
  switch (getAttributeValueType(type)) {
    case attributeValueType.ADDRESS:
      return new StunAddressAttribute(type, ...args);

    case attributeValueType.XOR_ADDRESS:
      return new StunXorAddressAttribute(type, ...args);

    case attributeValueType.UINT32:
      return new StunUInt32Attribute(type, ...args);

    case attributeValueType.BYTE_STRING:
      return new StunByteStringAttribute(type, ...args);

    case attributeValueType.ERROR_CODE:
      return new StunErrorCodeAttribute(type, ...args);

    case attributeValueType.UINT16_LIST:
      return new StunUInt16ListAttribute(type, ...args);

    case attributeValueType.UINT16:
      return new StunUInt16Attribute(type, ...args);

    default:
      break;
  }

  throw new Error(`Unsupported attribute type "${type}".`);
}

/**
 * Create attribute from arrived data.
 * @param {Object} attributePacket
 * @param {StunMessage} owner
 * @returns {StunAttribute}
 */
function parseAttribute(attributePacket, owner) {
  const { type, value } = attributePacket;

  switch (getAttributeValueType(type)) {
    case attributeValueType.ADDRESS:
      return StunAddressAttribute.from(type, value, owner);

    case attributeValueType.XOR_ADDRESS:
      return StunXorAddressAttribute.from(type, value, owner);

    case attributeValueType.UINT32:
      return StunUInt32Attribute.from(type, value, owner);

    case attributeValueType.BYTE_STRING:
      return StunByteStringAttribute.from(type, value, owner);

    case attributeValueType.ERROR_CODE:
      return StunErrorCodeAttribute.from(type, value, owner);

    case attributeValueType.UINT16_LIST:
      return StunUInt16ListAttribute.from(type, value, owner);

    case attributeValueType.UINT16:
      return StunUInt16Attribute.from(type, value, owner);

    default:
      break;
  }

  return StunUnknownAttribute.from(type, value, owner);
}

/**
 * Check if tranasction id is valid.
 * @param {Buffer} transactionId - `transction` field from a stun message.
 * @returns {boolean} The result of an operation.
 */
function isValidTransactionId(transactionId) {
  return (
    Buffer.isBuffer(transactionId) &&
    (transactionId.length === kStunTransactionIdLength ||
      transactionId.length === kStunLegacyTransactionIdLength)
  );
}

module.exports = StunMessage;
