const crypto = require('crypto')
const { crc32 } = require('crc')
const constants = require('lib/constants')

const { FINGERPRINT, MESSAGE_INTEGRITY } = constants.attributeType

module.exports = {
  validateFingerprint,
  validateMessageIntegrity
}

/**
 * Verifies that a given buffer is STUN by checking for a correct FINGERPRINT.
 * @param {StunMessage} stunMessage
 */
function validateFingerprint(stunMessage) {
  if (stunMessage.isLegacy()) {
    return false
  }

  const fingerprintAttr = stunMessage.getAttribute(
    FINGERPRINT
  )

  if (fingerprintAttr === undefined) {
    return false
  }

  const crc32buf = stunMessage.toBuffer().slice(0, -constants.kStunFingerprintLength)
  const currCRC32 = fingerprintAttr.value

  return ((crc32(crc32buf) ^ constants.kStunFingerprintXorValue) >>> 0) === currCRC32
}

/**
 * Validates that a raw STUN message has a correct MESSAGE-INTEGRITY value.
 * @param {StunMessage} stunMessage
 * @param {string} password
 */
function validateMessageIntegrity(stunMessage, password) {
  let offsetEnd = 0

  const fingerprintAttr = stunMessage.getAttribute(
    FINGERPRINT
  )
  const msgIntegrityAttr = stunMessage.getAttribute(
    MESSAGE_INTEGRITY
  )

  const isFingerprintExist = fingerprintAttr !== undefined

  // Calc offsets if FINGERPRINT attribute exist.
  if (isFingerprintExist) {
    offsetEnd += constants.kStunFingerprintLength
  }

  if (msgIntegrityAttr === undefined) {
    return false
  }

  offsetEnd += constants.kStunMessageIntegrityLength

  const buf = stunMessage.toBuffer().slice(0, -offsetEnd)

  // Remove length of FINGERPRINT attribute from message size.
  if (isFingerprintExist) {
    const currentLength = buf.readUInt16BE(2)
    buf.writeUInt16BE(currentLength - constants.kStunFingerprintLength, 2)
  }

  const hmac = crypto.createHmac('sha1', password)
  hmac.update(buf)

  return hmac.digest().equals(msgIntegrityAttr.value)
}
